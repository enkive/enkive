/*******************************************************************************
 * Copyright 2013 The Linux Box Corporation.
 *
 * This file is part of Enkive CE (Community Edition).
 *
 * Enkive CE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * Enkive CE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with Enkive CE. If not, see
 * <http://www.gnu.org/licenses/>.
 *******************************************************************************/
package com.linuxbox.enkive.workspace.searchQuery;

import static com.linuxbox.enkive.search.Constants.CONTENT_PARAMETER;
import static com.linuxbox.enkive.search.Constants.DATE_EARLIEST_PARAMETER;
import static com.linuxbox.enkive.search.Constants.DATE_LATEST_PARAMETER;
import static com.linuxbox.enkive.search.Constants.MESSAGE_ID_PARAMETER;
import static com.linuxbox.enkive.search.Constants.RECIPIENT_PARAMETER;
import static com.linuxbox.enkive.search.Constants.SENDER_PARAMETER;
import static com.linuxbox.enkive.search.Constants.SUBJECT_PARAMETER;
import static com.linuxbox.enkive.web.WebConstants.SEARCH_ID_TAG;
import static com.linuxbox.enkive.web.WebConstants.SEARCH_IS_IMAP;
import static com.linuxbox.enkive.web.WebConstants.SEARCH_IS_SAVED;
import static com.linuxbox.enkive.web.WebConstants.SEARCH_NAME_TAG;
import static com.linuxbox.enkive.web.WebConstants.SEARCH_PARAMETER_TAG;

import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.json.JSONException;
import org.json.JSONObject;

import com.linuxbox.enkive.message.search.MessageSearchSummary;
import com.linuxbox.enkive.workspace.WorkspaceException;
import com.linuxbox.enkive.workspace.searchResult.SearchResult;

/**
 * Represents a query consisting of a set of search criteria, and metadata for
 * the query.  This is the primary interface to search results.  It maintains a
 * link to the actual SearchResult objects that contain the snapshot of results
 * for the query, as well as the metadata about who search, when it happened,
 * and the state of the search.
 * 
 * @author eric
 * 
 */
public abstract class SearchQuery {
	public enum Status {
		QUEUED,

		RUNNING,

		COMPLETE,

		CANCEL_REQUESTED,

		CANCELED,

		ERROR,

		UNKNOWN; // when the status was read from DB, did not understand
	}

	private String id;
	private String name;
	private Map<String, String> criteria;
	private String executedBy;
	private Boolean isSaved = false;
	private Boolean isIMAP = false;
	private Date timestamp;
	private Status status;
	private String lastMonotonic;
	private Integer UIDValidity;

	protected SearchResult result;

	public SearchQuery() {
		criteria = new HashMap<String, String>();
		this.timestamp = new Date();
		name = this.timestamp.toString();
		this.status = Status.RUNNING;
		this.UIDValidity = 0;
	}

	/**
	 * Copy the portions of a query that are set during searching to this.  Copies
	 * results into this.result in the same fashion.
	 * @param query		Temporary query generated by MessageSearchService.searc
	 */
	public void copy(SearchQuery query) {
		this.executedBy = query.executedBy;
		this.timestamp = query.timestamp;
		this.status = query.status;
		this.lastMonotonic = query.lastMonotonic;
		this.result.copy(query.getResult());
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public SearchResult getResult() {
		return result;
	}

	public void setResult(SearchResult result) {
		this.result = result;
	}

	public Date getTimestamp() {
		return timestamp;
	}

	public void setTimestamp(Date timestamp) {
		this.timestamp = timestamp;
	}

	public Status getStatus() {
		return status;
	}

	public void setStatus(Status status) {
		this.status = status;
	}

	public String getExecutedBy() {
		return executedBy;
	}

	public void setExecutedBy(String executedBy) {
		this.executedBy = executedBy;
	}

	public Boolean isSaved() {
		return isSaved;
	}

	public void setSaved(Boolean isSaved) {
		this.isSaved = isSaved;
	}

	public Boolean isIMAP() {
		return isIMAP;
	}

	public void setIMAP(Boolean isIMAP) {
		this.isIMAP = isIMAP;
	}

	public String getLastMonotonic() {
		return lastMonotonic;
	}

	public void setLastMonotonic(String lastMonotonic) {
		this.lastMonotonic = lastMonotonic;
	}

	public Integer getUIDValidity() {
		return UIDValidity;
	}

	public void setUIDValidity(Integer UIDValidity) {
		this.UIDValidity = UIDValidity;
	}

	public void invalidateUID() {
		this.UIDValidity++;
	}

	public void addAllSearchCriteria(MessageSearchSummary searchSummary) {
		addAllSearchCriteria(searchSummary.sender, searchSummary.recipient,
				searchSummary.dateEarliest, searchSummary.dateLatest,
				searchSummary.subject, searchSummary.messageId,
				searchSummary.content);
	}

	public void addAllSearchCriteria(String sender, String recipient,
			Date dateEarliest, Date dateLatest, String subject,
			String messageId, String content) {
		if (sender != null && !sender.isEmpty())
			addCriterium(SENDER_PARAMETER, sender);
		if (recipient != null && !recipient.isEmpty())
			addCriterium(RECIPIENT_PARAMETER, recipient);
		if (dateEarliest != null)
			addCriterium(DATE_EARLIEST_PARAMETER, dateEarliest.toString());
		if (dateLatest != null)
			addCriterium(DATE_LATEST_PARAMETER, dateLatest.toString());
		if (subject != null && !subject.isEmpty())
			addCriterium(SUBJECT_PARAMETER, subject);
		if (messageId != null && !messageId.isEmpty())
			addCriterium(MESSAGE_ID_PARAMETER, messageId);
		if (content != null && !content.isEmpty())
			addCriterium(CONTENT_PARAMETER, content);
	}

	public Map<String, String> getCriteria() {
		return criteria;
	}

	public void setCriteria(Map<String, String> criteria) {
		this.criteria = criteria;
	}

	public void addCriterium(String parameter, String value) {
		criteria.put(parameter, value);
	}

	public String getCriterium(String parameter) {
		return criteria.get(parameter);
	}

	public Collection<String> getCriteriaParameters() {
		return criteria.keySet();
	}

	public boolean matches(Map<String, String> criteria) {
		return this.criteria.equals(criteria);
	}

	public JSONObject toJson() throws JSONException {
		JSONObject jsonQuery = new JSONObject();
		JSONObject jsonParameters = new JSONObject();

		for (String parameter : this.getCriteriaParameters()) {
			String value = this.getCriterium(parameter);
			jsonParameters.put(parameter, value);
		}

		jsonQuery.put(SEARCH_PARAMETER_TAG, jsonParameters);

		jsonQuery.put(SEARCH_NAME_TAG, this.getName());
		jsonQuery.put(SEARCH_ID_TAG, this.getId());

		if (this.isSaved()) {
			jsonQuery.put(SEARCH_IS_SAVED, "true");
		} else {
			jsonQuery.put(SEARCH_IS_SAVED, "false");
		}
		if (this.isIMAP()) {
			jsonQuery.put(SEARCH_IS_IMAP, "true");
		} else {
			jsonQuery.put(SEARCH_IS_IMAP, "false");
		}

		return jsonQuery;
	}

	public abstract void saveSearchQuery() throws WorkspaceException;

	public abstract void deleteSearchQuery() throws WorkspaceException;
}
